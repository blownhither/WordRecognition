import numpy as npclass FFT:    def __init__(self, n=256):        self.L = len(bin(n)) - 2        self.W = [np.exp(-2j * np.pi * np.arange(1 << i) / (1 << i)) for i in range(self.L)]    def _fft(self, x, order):        assert len(x) == 1 << order        if order == 0:            return x        if order == 1:            return np.array([np.sum(x), np.sum(x * self.W[1])])        X1 = self._fft(x[::2], order - 1)        X2 = self._fft(x[1::2], order - 1)        ret1 = X1 + self.W[order][:1 << (order - 1)] * X2        ret2 = X1 + self.W[order][1 << (order - 1):] * X2        return np.concatenate((ret1, ret2), 0)    # TODO: Precision problem    def fft(self, x):        order = len(bin(len(x))) - 3        x = np.array(x)        if len(x) > (1 << order):            order += 1            x = np.concatenate((x, np.zeros((1 << order) - len(x))), 0)        assert order <= self.L        assert (1 << order) ^ len(x) == 0        return self._fft(x, order)    def ifft(self, x):        f = np.conj(self.fft(np.conj(x)))        order = len(bin(len(x))) - 3        if len(x) > (1 << order):            order += 1        f /= (1 << order)        return fdef _test():    f = FFT()    a = np.random.random(128)    v1 = f.ifft(a)    v2 = np.fft.ifft(a)    print(v1 - v2)    print((np.abs(v1 - v2) < 1e-10).all())if __name__ == '__main__':    _test()